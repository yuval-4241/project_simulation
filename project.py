# -*- coding: utf-8 -*-
"""PROJECT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1toGkoOr17dG4j6GfhXHlpu83naNMedRP
"""



from samples import *




class Customer:

    def __init__(self, group_type, group_id):
        self.group_id = group_id
        self.expenses = 0
        self.rank = 10
        self.group_type = group_type

        # Initialize daily activities and max waiting time
        self.daily_activities = self.init_daily_activities()
        self.max_waiting_time = self.set_max_waiting_time()

    def init_daily_activities(self):
        """Initialize daily activities based on group type."""
        activities = {
            "family": {"pool": [False, 0], "bar": [False, 0]},
            "couple": {"spa": [False, 0], "pool": [False, 0]},
            "one": {"spa": [False, 0], "bar": [False, 0], "pool": [False, 0]},
        }
        return activities.get(self.group_type, {})

    def set_max_waiting_time(self):
        """Set the maximum waiting time based on group type."""
        wait_times = {"family": 10, "couple": 15, "one": 20}
        return wait_times.get(self.group_type, 15)

    def updateRank(self, rank_decrease):
        """Decrease the rank of the customer, ensuring it doesn't drop below zero."""
        self.rank = max(0, self.rank - rank_decrease)

    def addExpense(self, expense):
        """Add an expense to the customer's total spending."""
        self.expenses += expense

    def getGuestExpenses(self):
        """Return the total expenses of the customer."""
        return self.expenses

    def haveToDoActivity(self, activity_type):
        """Check if the customer still needs to perform a specific activity."""
        if activity_type not in self.daily_activities:
            return False
        completed, attempts = self.daily_activities[activity_type]
        return not completed and attempts < 2

    def get_max_waiting_time(self):
        """
        return the waiting time of the customer
        """
        return self.max_waiting_time

    def checkGroupType(self):
        """Return the group type of the customer."""
        return self.group_type

    def updateRankExitLongQ(self):
        """Reduce the rank of the customer for long queue waits."""
        self.updateRank(0.03)

    def updateBarExpenses(self):
        """Simulate the expenses for the customer at the bar."""
        u1 = np.random.uniform()
        u2 = np.random.uniform()

        if self.group_type == "family":
            if u1 < 0.5:  # Drinks
                self.addExpense(3)  # Coffee or juice
            else:  # Food
                self.addFoodExpense(u2)
        else:
            if u1 < 0.5:  # Drinks
                if u2 < (3 / 7):
                    self.addExpense(3)  # Coffee, juice, or beer
                elif u2 < (4 / 7):
                    self.addExpense(10)  # Wine
                else:
                    self.addExpense(15)  # Cocktails, whiskey, or cognac
            else:  # Food
                self.addFoodExpense(u2)

    def addFoodExpense(self, prob):
        """Helper function to determine food expense based on probability."""
        if prob < 0.25:
            self.addExpense(10)  # Toast
        elif prob < 0.5:
            self.addExpense(12)  # Salad
        elif prob < 0.75:
            self.addExpense(3)  # Ice Cream
        else:
            self.addExpense(15)  # French fries

    def __str__(self):
        """Return a string representation of customer details."""
        return f"Id: {self.customer_id}, Rank: {self.rank}, Expenses: ${self.expenses:.2f}"

import numpy as np

class Booking:
    totalBookings = 0  # Static variable to track the total number of bookings

    def __init__(self, arrivalTime):
        """
        Initialize a new booking with group details and activities.
        """
        Booking.totalBookings += 1
        self.bookingId = Booking.totalBookings
        self.customers = []  # Changed to lowercase for consistency
        self.numGuests = sampleCustomerCount()
        self.stayDuration = sampleStayDuration()
        self.arrivalTime = arrivalTime
        self.breakfastArrivalTimes = []  # To store breakfast times for each day
        self.groupType = self.determineGroupType()

        # Create customers based on the group category
        for _ in range(self.numGuests):
            self.customers.append(Customer(self.groupType, self.bookingId))

    def initializeDailyActivities(self):
        """
        Set up daily activities for customers based on group category.
        """
        activityMapping = {
            "family": {"pool": [False, 0], "bar": [False, 0]},
            "triple": {"pool": [False, 0], "bar": [False, 0]},
            "couple": {"spa": [False, 0], "pool": [False, 0]},
            "one": {"spa": [False, 0], "bar": [False, 0], "pool": [False, 0]}
        }
        for customer in self.customers:
            customer.dailyActivities = activityMapping.get(self.groupType, {}).copy()

    def calculateGroupRank(self):
        """
        Compute the average rank for the group.
        """
        return sum(customer.rank for customer in self.customers) / self.numGuests

    def allActivitiesCompleted(self):
        """
        Verify if all customers have completed their activities for the day.
        """
        for customer in self.customers:
            activities = customer.dailyActivities
            if any(not completed and attempts < 2 for completed, attempts in activities.values()):
                return False
        return True

    def getGroupSize(self):
        """
        Return the size of the group.
        """
        return self.numGuests
    def getDurationtime(self):
        return self.stayDuration
    def determineGroupType(self):
        """
        Categorize the group based on its size.
        """
        if self.numGuests == 3:
            return "triple"
        elif self.numGuests >= 4:
            return "family"
        elif self.numGuests == 2:
            return "couple"
        return "one"

    def maxWaitingTime(self):
        """
        Return the maximum waiting time for the group based on its category.
        """
        return {"family": 10,"triple":10, "couple": 15, "one": 20}.get(self.groupType, 20)

    def adjustRankDueToRoomDelay(self, roomAssignmentTime):
        """
        Adjust customer ranks for delayed room assignment.
        """
        baseArrivalTime = max(self.arrivalTime, 15 * 60 + (self.arrivalTime // (24 * 60)) * 24 * 60)
        penalty = ((roomAssignmentTime - baseArrivalTime) // 30) * 0.02
        for customer in self.customers:
            customer.updateRank(penalty)

    def adjustRankForCheckInWait(self, checkInStartTime):
        """
        Penalize customers for waiting in the check-in queue.
        """
        waitDuration = checkInStartTime - self.arrivalTime
        penalty = (waitDuration // 20) * 0.02
        for customer in self.customers:
            customer.updateRank(penalty)

    def adjustRankForBreakfastWait(self, breakfastStartTime):
        """
        Penalize customers for waiting in the breakfast queue.
        """
        waitDuration = breakfastStartTime - self.arrivalTime
        penalty = (waitDuration // 20) * 0.02
        for customer in self.customers:
            customer.updateRank(penalty)

    def penalizeLongQueueExit(self):
        """
        Deduct rank for customers leaving due to long queues.
        """
        for customer in self.customers:
            customer.updateRank(0.03)

    def calculateTotalExpenses(self, roomType):
        """
        Calculate the total cost for the group.
        """
        baseRate = 370 if roomType == "Suite" else 250
        roomCost = self.stayDuration * baseRate
        additionalCosts = sum(customer.getGuestExpenses() for customer in self.customers)
        totalCost = roomCost + additionalCosts
        print(f"Total booking expenses: {totalCost}")
        return totalCost

    def isFirstDay(self, currentTime):
        """
        Check if it's the first day of the group's stay.
        """
        return currentTime // (24 * 60) == self.arrivalTime // (24 * 60)

    def isLastDay(self, currentTime):
        """
        Check if it's the last day of the group's stay.
        """
        return currentTime // (24 * 60) == (self.arrivalTime // (24 * 60) + self.stayDuration)

    def displayGroupInfo(self):
        """
        Display detailed information about the group.
        """
        print(f"Booking ID: {self.bookingId}")
        print(f"Number of Guests: {self.numGuests}")
        print(f"Group Type: {self.groupType}")
        print("Customers in this booking:")
        for customer in self.customers:
            customer.printGuest()

class Table:
    """
    מחלקה המייצגת שולחן במסעדת המלון
    """
    def __init__(self):
        self.is_occupied = False  # האם השולחן תפוס

    def set_status(self, status):
        """
        שינוי סטטוס השולחן
        :param status: True אם תפוס, False אם פנוי
        """
        self.is_occupied = status

class Room:
    totalRooms = 0  # Static variable to track the total number of rooms created

    def __init__(self, roomType):
        """
        Initialize a Room instance.
        :param roomType: Type of the room (e.g., Suite, Family).
        """
        Room.totalRooms += 1
        self.roomId = Room.totalRooms
        self.roomType = roomType
        self.currentBooking = None  # The guest group currently occupying the room
        self.available = True  # Indicates if the room is free

    def performCheckOut(self):
        """
        Mark the room as free and disassociate it from the current guest group.
        """
        self.currentBooking = None
        self.available = True

    def isAvailable(self):
        """
        Check if the room is free.
        :return: True if the room is not occupied, False otherwise.
        """
        return self.available

    def bookRoom(self, booking):
        """
        Assign a guest group to the room and mark it as occupied.
        :param guestGroup: The guest group to assign to the room.
        """
        self.currentBooking = booking
        self.available = False

    def getCurrentBooking(self):
        """
        Return the current guest group occupying the room.
        :return: The current booking (guest group) or None if the room is unoccupied.
        """
        return self.currentBooking

    def displayRoomDetails(self):
        """
        Print details about the room, including its current status and guest group.
        """
        print(f"Room ID: {self.roomId}, Type: {self.roomType}, Clean: {self.cleanStatus}, Available: {self.available}")
        if self.currentBooking is not None:
            self.currentBooking.displayGroupInfo()

class Employee:
    def __init__(self, employee_id):
        """
        Initialize an Employee instance.
        :param employee_id: Unique ID for the employee.
        """
        self.employee_id = employee_id
        self.active_status = False  # Indicates if the employee is currently working

    def isWorking(self):
        """
        Check if the employee is currently working.
        :return: True if the employee is active, False otherwise.
        """
        return self.active_status

    def setWorkingStatus(self, status):
        """
        Update the employee's working status.
        :param status: True to mark as working, False otherwise.
        """
        self.active_status = status

    def displayDetails(self):
        """
        Display the details of the employee.
        """
        print(f"Employee ID: {self.employee_id}, Active: {self.active_status}")


class HouseKeeper(Employee):
    def __init__(self, employee_id, assigned_rooms):
        """
        Initialize a HouseKeeper instance.
        :param employee_id: Unique ID for the employee.
        :param assigned_rooms: List of rooms assigned to the housekeeper.
        """
        super().__init__(employee_id)
        self.assigned_rooms = assigned_rooms  # List of rooms assigned for cleaning

    def cleanAssignedRoom(self, room):
        """
        Mark the room as cleaned.
        :param room: The room object to clean.
        """
        room.markAsClean()

    def getNextRoomToClean(self):
        """
        Find the next room that requires cleaning.
        :return: The next room needing cleaning, or None if all are clean.
        """
        for room in self.assigned_rooms:
            if room.requiresCleaning():
                return room
        return None

    def displayDetails(self):
        """
        Display details of the housekeeper, including assigned rooms.
        """
        super().displayDetails()
        print("Assigned Rooms:")
        for room in self.assigned_rooms:
            room.displayRoomDetails()

class Facilities:
    """
    A class to manage hotel facilities such as spa, pool, and breakfast.
    """
    def __init__(self, max_capacity):
        """
        Initialize the Facilities instance.
        :param max_capacity: Maximum capacity for the facility.
        """
        self.max_capacity = max_capacity
        self.current_occupancy = 0
        self.waiting_queue = []
        self.current_bookings = []

    def isFacilityAvailable(self, customer):
        """
        Check if there is space available for the customer in the facility.
        :param customer: Either a group or an individual guest.
        :return: True if space is available, False otherwise.
        """
        needed_space = customer.getGroupLength() if isinstance(customer, Booking) else 1
        return self.current_occupancy + needed_space <= self.max_capacity

    def hasWaitingQueue(self):
        """
        Check if there are customers in the waiting queue.
        :return: True if the queue is not empty, False otherwise.
        """
        return bool(self.waiting_queue)

    def admitToFacility(self, customer):
        """
        Admit a customer or group to the facility.
        :param customer: Either a GuestGroup or an individual guest.
        """
        occupancy_change = customer.getGroupLength() if isinstance(customer, Booking) else 1
        self.current_occupancy += occupancy_change
        self.active_customers.append(customer)

    def removeFromFacility(self, customer, booking):
        """
        Remove a customer or group from the facility.
        :param customer: Either a GuestGroup or an individual guest.
        """
        occupancy_change = customer.getGroupLength() if isinstance(customer, booking) else 1
        self.current_occupancy -= occupancy_change
        self.active_customers.remove(customer)

    def isInQueue(self, customer):
        """
        Check if a customer is in the waiting queue.
        :param customer: Either a GuestGroup or an individual guest.
        :return: True if the customer is in the queue, False otherwise.
        """
        return customer in self.waiting_queue

    def addToQueue(self, customer):
        """
        Add a customer to the waiting queue.
        :param customer: Either a GuestGroup or an individual guest.
        """
        self.waiting_queue.append(customer)

    def removeFromQueue(self):
        """
        Remove and return the next customer from the waiting queue.
        :return: The next customer in the queue.
        """
        return self.waiting_queue.pop(0) if self.waiting_queue else None

    def addBooking(self, booking):
        """
        מוסיף הזמנה לרשימת ההזמנות הנוכחיות אם יש מקום פנוי.
        :param booking: אובייקט הזמנה להוספה.
        """
        if len(self.current_bookings) < self.max_capacity:
            self.current_bookings.append(booking)

    def removeBooking(self, booking):
        """
        מסיר הזמנה מרשימת ההזמנות הנוכחיות.
        :param booking: אובייקט הזמנה להסרה.
        """
        if booking in self.current_bookings:
            self.current_bookings.remove(booking)

    def hasCapacity(self):
        """
        בודק אם יש מקום פנוי במתקן.
        :return: True אם יש מקום פנוי, אחרת False.
        """
        return len(self.current_bookings) < self.max_capacity

class Bar:
    def __init__(self):
        self.bar1 = Employee(5)
        self.bar2 = Employee(6)
        self.queue = []

    def isInQueue(self, guest):
        return guest in self.queue

    def findAvailableBartender(self):
        if not self.bar1.isWorking():
            return self.bar1
        if not self.bar2.isWorking():
            return self.bar2
        return None

import heapq
import numpy as np

class hotelSimulation:
    def __init__(self):
        # stats for breakfest:

        self.breakfast_open = False  # Breakfast status (open 06:30-11:30)
        self.breakfast_queue = []  # Guests waiting for breakfast
        self.tables = [Table() for _ in range(12)]

        self.family_rooms = [Room("family") for _ in range(30)]  # 30 חדרי משפחה
        self.triple_rooms = [Room("triple") for _ in range(40)]  # 40 חדרי טריפל
        self.couple_rooms = [Room("couple") for _ in range(30)]  # 30 חדרי זוג
        self.suite_rooms = [Room("suite") for _ in range(10)]    # 10 סוויטות
        self.free_rooms_count = 110

        self.pool = Facilities(max_capacity=50)
        self.diningRoom = Facilities(max_capacity=60)
        self.spa = Facilities(max_capacity=30)
        self.hotel_rank = 7  # Initial rank of the hotel
        self.daily_rank = self.hotel_rank  # Updated rank daily
        self.arrival_rate = self.calculate_average_rating()
        self.public_open = False
        self.check_in_open = False  # Check-in status (open 15-20)
        self.check_out_open = False  # Check-out status (open 07:30-11)
        self.public_open = False  # Public entry (open 08-17)
        self.activities_open = False  # Activities (open 07-19)


        self.total_waiting_time = 0  # מצטבר של זמני ההמתנה של כל הלקוחות

        #stats for checking groups:
        self.total_guest_groups=0
        self.total_guest_in_check_in_queue=0
        self.waiting_times_check_in=[]
        self.assignRoomscount = 0
        self.count_chekin_queue=0
        self.server1 = Employee(1)  # Check-in/out server 1
        self.server2 = Employee(2)  # Check-in/out server 2
        self.check_in_queue = []
        self.check_out_queue = []
        self.lobby_queue = []  # Guests waiting for rooms
        self.nothaveroom =0
        self.num_servers = 2
        self.servers_busy = 0







    def calculate_average_rating(self):
        rate_factor = (self.count_free_rooms() / 110) ** 1.5
        rank_factor = (self.hotel_rank / 10) ** 2
        self.arrival_rate = 20 * rate_factor * rank_factor * self.check_free_rooms()

    def get_arrival_rate(self):
        return self.arrival_rate

    def set_public_status(self, status):
        self.public_open = status

    def set_check_out_status(self, status):
        self.check_out_open = status

    def setCheckInOpen(self, status):
        """
        Set the status of the check-in process (open/close).
        :param status: True to open, False to close.
        """
        self.check_in_open = status

    def set_activities_status(self, status):
        self.activities_open = status

    def set_breakfast_status(self, status):
        self.breakfast_open = status

    def setPublicAccess(self,status):
        self.public_open = status

    def build_rooms(self):
        for _ in range(30):
            self.family_rooms.append(Room("family"))
        for _ in range(40):
            self.triple_rooms.append(Room("triple"))
        for _ in range(30):
            self.couple_rooms.append(Room("couple"))
        for _ in range(10):
            self.suite_rooms.append(Room("suite"))
    def is_server_available(self):
        """
        בדיקת זמינות של שרתים.
        """
        return self.servers_busy < self.num_servers

    def assign_to_server(self, time):
        """
        הקצאת שרת לקבוצה.
        """
        self.servers_busy += 1





    def find_group_by_guest(self, customer):
        for room_list in [self.family_rooms, self.triple_rooms, self.couple_rooms, self.suite_rooms]:
            for room in room_list:
                if room.current_booking and room.current_booking.groupId == customer.customerId:
                    return room.current_booking
        return None

    def count_free_rooms(self):
        return sum(1 for room_list in [self.family_rooms, self.triple_rooms, self.couple_rooms, self.suite_rooms] for room in room_list if room.isAvailable())

    def check_free_rooms(self):
        return 1 if self.count_free_rooms() > 0 else 0

    def assignRoom(self, booking):
        """
        Assign a room to the given booking based on the group size.
        :param booking: Booking object containing group details.
        :return: True if a room was successfully assigned, False otherwise.
        """
        booking_size = booking.getGroupSize()

        # הגדרת סדר החיפוש לפי גודל הקבוצה
        if booking_size >= 4:
            room_list = self.family_rooms  # חדרי משפחות ל-4 ומעלה
        elif booking_size == 3:
            room_list = self.triple_rooms  # חדרי טריפל ל-3 אורחים
        elif booking_size == 2:
            # בדיקה אם ההזמנה מתאימה לסוויטה
            if sampleIsSuite(2):
                room_list = self.suite_rooms
            else:
                room_list = self.couple_rooms
        else:
            # בדיקה אם ההזמנה מתאימה לסוויטה ליחיד
            if sampleIsSuite(1):
                room_list = self.suite_rooms
            else:
                room_list = self.couple_rooms


        # חיפוש החדר הפנוי הראשון והקצאתו
        for room in room_list:
            if room.isAvailable():
                room.bookRoom(booking)
                self.assignRoomscount += 1
                return True
            self.nothaveroom += 1  # אם לא נמצא חדר מתאים
            return False

    def locateRoomByGroup(self, booking):
        for room_list in [self.family_rooms, self.triple_rooms, self.couple_rooms, self.suite_rooms]:
            for room in room_list:
                if room.currentBooking == booking:
                    return room
        return None

    def determine_next_activity(self, customer, current_activity):
        activity_flow = {
            "pool": ["spa", "bar"],
            "spa": ["pool", "bar"],
            "bar": ["breakfast"]
        }
        next_activities = activity_flow.get(current_activity, [])
        for activity in next_activities:
            if customer.haveToDoActivity(activity):
                return activity, customer
        return None, None

    def resetDailyActivities(self, customers):
      """
      Reset daily activities for all guests in the group based on the group category.
      """
      activityMapping = {
        "family": {"pool": [False, 0], "bar": [False, 0]},
        "couple": {"spa": [False, 0], "pool": [False, 0]},
        "one": {"spa": [False, 0], "bar": [False, 0], "pool": [False, 0]}
    }
      for customers in self.Booking:
        customers.dailyActivities = activityMapping.get(self.groupCategory, {}).copy()

    def update_daily_rank(self, guest_group):
        group_rank = guest_group.calculateGroupRank()
        self.daily_rank = (self.daily_rank * self.total_guest_groups + group_rank) / (self.total_guest_groups + 1)
        self.total_guest_groups += 1

    def setDailyRating(self, rating):
        """
        Set the daily rating of the hotel.
        :param rating: The new daily rating to be set.
        """
        self.daily_rank = rating

    def getCurrentRating(self):
        """
        Get the current rating of the hotel.
        :return: The current daily rank of the hotel.
        """
        return self.daily_rank

    def updateArrivalRate(self):
        """
        Update the arrival rate of guests based on the current hotel rating.
        """
        rate_factor = (self.count_free_rooms() / 110) ** 1.5
        rank_factor = (self.daily_rank / 10) ** 2
        self.arrival_rate = 20 * rate_factor * rank_factor * self.check_free_rooms()

    def setDailyRating(self, rating):
        """
        Set the daily rating of the hotel.
        :param rating: The new daily rating to be set.
        """
        self.daily_rank = rating

    def getCurrentRating(self):
        """
        Get the current rating of the hotel.
        :return: The current daily rank of the hotel.
        """
        return self.daily_rank

    def display_hotel_status(self):
        print("Hotel Simulation Details")
        for housekeeper in self.housekeepers:
            housekeeper.printEmployee()

    def setBreakfastOpen(self, status):
        """
        Set the status of the breakfast area (open/close).
        :param status: True to open, False to close.
        """
        self.breakfast_open = status

    # מתודה חדשה לפתיחת או סגירת אזורי הפעילויות
    def setActivitiesOpen(self, status):
        """
        Set the status of the activity areas (open/close).
        :param status: True to open, False to close.
        """
        self.activities_open = status

    def setCheckOutOpen(self, status):
        """
        Set the status of the check-out process (open/close).
        :param status: True to open, False to close.
        """
        self.check_out_open = status

  #----------------------breackfest------------------------------------------------------
    def find_available_table(self):
          """
          מחזיר את האינדקס של השולחן הפנוי הראשון או None אם אין שולחן פנוי.
          """
          for index, table in enumerate(self.tables):
              if not table.is_occupied:
                  return index
          return None


    def count_available_tables(self):
          """
          חישוב כמה שולחנות פנויים נשארו
          :return: מספר השולחנות הפנויים
          """
          return sum(1 for table in self.tables if not table.is_occupied)

import heapq
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import truncnorm

class Event:
    def __init__(self, time):
        self.time = time

    def __lt__(self, other):
        return self.time < other.time

    def handle(self, simulation):
        raise NotImplementedError("Handle method must be implemented by subclasses")

class OpenHotelEvent(Event): #open the hotel to guests at 8am
    def handle(self,simulation):
        simulation.hotelSimulation.setPublicAccess(True)
        simulation.scheduleEvent(CloseHotelEvent(self.time+9*60)) #schedule closure at 5pm
        next_arrival_time = self.time + sampleCustomerArrival(simulation.hotelSimulation)
        arrival_end_time = 17 * 60  # סיום ההגעה ב-17:00
        if next_arrival_time < simulation.simulationTime and self.time < arrival_end_time:
            simulation.scheduleEvent(CustomerArrivalEvent(next_arrival_time))
        simulation.scheduleEvent(CheckInArrivalEvent(15 * 60))

class CloseHotelEvent(Event): #close the hotel to guests at 5pm
    def handle(self,simulation):
        simulation.hotelSimulation.setPublicAccess(False)
        simulation.scheduleEvent(OpenHotelEvent(self.time+15*60)) #schedule reopening at 8am

class OpenActivitiesEvent(Event): #open activity areas like pool and spa at 7am
    def handle(self,simulation):
        simulation.hotelSimulation.setActivitiesOpen(True)
        simulation.scheduleEvent(CloseActivitiesEvent(self.time+12*60))

class CloseActivitiesEvent(Event): #close activity areas like pool and spa at 7pm
    def handle(self,simulation):
        simulation.hotelSimulation.setActivitiesOpen(False)
        simulation.scheduleEvent(OpenActivitiesEvent(self.time+12*60))

class OpenDiningEvent(Event): #open dining area at 6:30am
    def handle(self,simulation):
        simulation.hotelSimulation.setBreakfastOpen(True)
        simulation.scheduleEvent(CloseDiningEvent(self.time+5*60))

class CloseDiningEvent(Event): #close dining area at 11:30am
    def handle(self,simulation):
        simulation.hotelSimulation.setBreakfastOpen(False)
        simulation.scheduleEvent(OpenDiningEvent(self.time+19*60))

class StartCheckInEvent(Event): #start the check-in process at 3pm
    def handle(self,simulation):
        simulation.hotelSimulation.setCheckInOpen(True)
        simulation.scheduleEvent(EndCheckInEvent(self.time+5*60))

class EndCheckInEvent(Event):  # סיום תהליך הצ'ק-אין ב-20:00
    def handle(self, simulation):
        simulation.hotelSimulation.setCheckInOpen(False)  # סגירת תהליך הצ'ק-אין
        simulation.scheduleEvent(StartCheckInEvent(self.time + 19 * 60))  # תזמון פתיחת הצ'ק-אין הבא בעוד 19 שעות

class StartCheckOutEvent(Event): #start the check-out process at 7:30am
    def handle(self,simulation):
        simulation.hotelSimulation.setCheckOutOpen(True)
        simulation.scheduleEvent(EndCheckOutEvent(self.time+3.5*60))

class EndCheckOutEvent(Event): #end the check-out process at 11am
    def handle(self,simulation):
        simulation.hotelSimulation.setCheckOutOpen(False)
        simulation.scheduleEvent(StartCheckOutEvent(self.time+20.5*60))

class AssignKeysEvent(Event): #assign room keys to clean and available rooms at 3pm
    def handle(self,simulation):
        for booking in simulation.hotelSimulation.lobby_queue:
            assignedRoom = simulation.hotelSimulation.locateRoomByGroup(booking)
        simulation.scheduleEvent(AssignKeysEvent(self.time+24*60))

    def updateFoodRating(self, booking):
        for customer in booking.guests:
            if np.random.uniform() < 0.1:
                customer.updateRank(0.025)

#class InitializeDailyEvent(Event):  # אתחול יומי של פעילויות ב-6:30 בבוקר
#    def handle(self, simulation):
#        for roomType in [simulation.hotelSimulation.family_rooms, simulation.hotelSimulation.triple_rooms, simulation.hotelSimulation.couple_rooms, simulation.hotelSimulation.suite_rooms]:
#            for room in roomType:
#                booking = room.getCurrentBooking()
#                if booking is not None:  # רק אם יש הזמנה פעילה
#                    booking.initializeDailyActivities()
#        simulation.scheduleEvent(InitializeDailyEvent(self.time + 24 * 60))  # תזמון האתחול היומי הבא

class UpdateRateEvent(Event):  # עדכון קצב ההגעה בהתבסס על הדירוג היומי
    def handle(self, simulation):
        simulation.hotelSimulation.setDailyRating(simulation.hotelSimulation.getCurrentRating())  # עדכון הדירוג היומי
        simulation.hotelSimulation.updateArrivalRate()  # עדכון קצב ההגעה
        simulation.scheduleEvent(UpdateRateEvent(self.time + 24 * 60))  # תזמון האירוע ליום הבא


class CustomerArrivalEvent(Event):
    def handle(self, simulation):
        """
        Handle the arrival of a customer group to the hotel.
        """

        # בדיקה אם המלון פתוח לציבור (מתחיל ב-8:00)
        if not simulation.hotelSimulation.public_open:
            return  # אם המלון סגור, אין מה להוסיף לקבוצות הממתינות

        # יצירת גודל קבוצה אקראי והוספת הקבוצה לתור ההמתנה בלובי
         # גודל הקבוצה
        new_booking = Booking(arrivalTime=self.time)

        heapq.heappush(simulation.hotelSimulation.lobby_queue, (self.time, new_booking))


        simulation.hotelSimulation.total_guest_groups += 1

        # תזמון הגעת הקבוצה הבאה
        next_arrival_time = self.time + sampleCustomerArrival(simulation.hotelSimulation)
        arrival_end_time = 17 * 60  # סיום ההגעה ב-17:00
        if next_arrival_time < simulation.simulationTime and self.time < arrival_end_time:
            simulation.scheduleEvent(CustomerArrivalEvent(next_arrival_time))





class CheckInArrivalEvent(Event):
    def handle(self, simulation):


        # עיבוד תור הלובי כל עוד יש קבוצות בתור ויש חדרים פנויים
        while simulation.hotelSimulation.lobby_queue and simulation.hotelSimulation.count_free_rooms() > 0:
            # בדיקה אם יש פקיד פנוי
            booking_time, booking = heapq.heappop(simulation.hotelSimulation.lobby_queue)
            # שליפת הקבוצה הבאה מהערימה
            if simulation.hotelSimulation.is_server_available():
                simulation.hotelSimulation.assign_to_server(self.time)

                # בדיקה אם ניתן להקצות חדר לקבוצה
                if simulation.hotelSimulation.assignRoom(booking):
                    service_time=sampleCheckIn()*60

                    # תזמון סיום הצ'ק-אין
                    simulation.scheduleEvent(CheckInDepartureEvent(self.time + service_time, booking))

                    # תזמון ארוחות בוקר לכל יום למעט היום האחרון
                    for day in range(booking.getDurationtime()- 1):
                        breakfast_time = sampleBreakfastTime() + day * 1440
                        simulation.scheduleEvent(BreakfastArrivalEvent(self.time + breakfast_time, booking.bookingId))


                    # תזמון צ'ק-אאוט ביום האחרון בשעה 11:00
                    checkout_time = (booking.getDurationtime() - 1) * 1440 + 660  # יום אחרון ב-11:00
                    simulation.scheduleEvent(CheckoutArrivleEvent(self.time + checkout_time, booking))
                else:
                    simulation.hotelSimulation.nothaveroom+=1

            else:
                # אין פקיד פנוי, מוסיפים את הקבוצה לתור צ'ק-אין
                simulation.hotelSimulation.check_in_queue.append(booking)
                simulation.hotelSimulation.count_chekin_queue +=1
                break

class CheckInDepartureEvent(Event):
    def __init__(self, time, booking):
        super().__init__(time)
        self.booking = booking



    def handle(self, simulation):
        """
        Handle the completion of the check-in process.
        """
        # בדיקה אם יש לקוחות נוספים בתור הצ'ק-אין

        if simulation.hotelSimulation.check_in_queue:
            # שליפת ההזמנה הבאה בתור
            next_booking = simulation.hotelSimulation.check_in_queue.pop(0)
            next_customer_arrival_time = next_booking.arrivalTime

            # חישוב זמן ההמתנה של הלקוח הבא
            waiting_time = self.time - next_customer_arrival_time
            simulation.hotelSimulation.total_waiting_time += waiting_time
            simulation.hotelSimulation.waiting_times_check_in.append(waiting_time)
            simulation.hotelSimulation.assign_to_server(self.time)
        else:
            # אם אין קבוצות בתור, השרת מסומן כפנוי
            simulation.hotelSimulation.servers_busy -= 1



class CheckoutArrivleEvent(Event):
    def __init__(self, time, booking):
      super().__init__(time)
      self.booking=booking

    def handle(self, simulation):
      if simulation.hotelSimulation.check_out_open:
        server = simulation.hotelSimulation.find_available_server()
        if server is not None:
          server.setWorkingStatus(True)
          serviceTime=sampleCheckOut()
          simulation.scheduleEvent(CheckOutDepartureEvent(self.time+serviceTime, server, self.bookingId))
        else:
          simulation.hotelSimulation.check_out_queue.append(self.booking)

class CheckOutDepartureEvent(Event):
    def __init__(self, time, server, booking):
      super().__init__(time)
      self.server = server
      self.booking = booking

    def handle(self,simulation):

        room = simulation.hotelSimulation.locateRoomByGroup(self.booking)
        if room is not None:
            room.performCheckOut()
        self.server.setWorkingStatus(False)
        simulation.hotelSimulation.update_daily_rank(self.booking)
        if len(simulation.hotelSimulation.check_out_queue) > 0:
            next_booking = simulation.hotelSimulation.check_out_queue.pop(0)
            server = simulation.hotelSimulation.find_available_server()
            if server:
                server.setWorkingStatus(True)
                service_time = sampleCheckOut()
                simulation.scheduleEvent(CheckOutDepartureEvent(self.time + service_time, server, next_booking))

class BreakfastArrivalEvent(Event):
    def __init__(self, time, booking_id):
        super().__init__(time)
        self.booking_id=booking_id

    def handle(self, simulation):

        breakfast_start_time = 6.5 * 60  # שעה 6:30 במונחי דקות
        breakfast_end_time = 11 * 60    # שעה 11:00 במונחי דקות

        # בדיקה אם הזמן הוא במסגרת שעות פעילות חדר האוכל
        if not (breakfast_start_time <= self.time < breakfast_end_time):
            return  # אם חדר האוכל סגור, האירוע לא מבוצע
        available_table_index = simulation.hotel.find_available_table()
        if available_table_index is not None:
            # סימון השולחן כתפוס
            simulation.hotel.tables[available_table_index].set_status(True)
            breakfast_duration = simulation.sampleBreakfastTime()

            # תזמון עזיבה מארוחת הבוקר
            simulation.schedule_event(BreakfastDepartureEvent(self.time + breakfast_duration, self.booking_id, available_table_index))
        else:
            simulation.breakfast_queue.append(self.customer_id)


class BreakfastDepartureEvent(Event):
    def __init__(self, time, booking_id, table_index):
        super().__init__(time)
        self.booking_id=booking_id
        self.table_index=table_index


    def handle(self, simulation):
      if breakfast_queue:
        next_customer_arrival_time = simulation.recption_queue.pop(0)
        waiting_time = self.time - next_customer_arrival_time
        simulation.total_waiting_time += waiting_time
        simulation.hotel.tables[available_table_index].set_status(True)
        if booking.isLastDay(self.time):
            simulation.schedule_event(CheckOutArrivalEvent(self.time, self.booking_id))
        else:
            # אם לא היום האחרון, ניתן להוסיף פעילויות נוספות לפי הצורך
            pass



import numpy as np

class Simulation:
    def __init__(self, simulationTime):
        """
        Initialize the simulation with hotel instance and event queue.
        :param simulationTime: Total time for the simulation (in minutes).
        """
        self.simulationTime = simulationTime  # משך זמן הסימולציה
        self.hotelSimulation = hotelSimulation()  # אובייקט המלון לניהול כל התהליכים
        self.clock = 0  # שעון הסימולציה
        self.event_list = []  # רשימת אירועים (תור עדיפויות)
        self.total_waiting_time = 0  # מצטבר של זמני ההמתנה של כל הלקוחות


    def scheduleEvent(self, event):
        heapq.heappush(self.event_list, event)

    def run(self):
        """
        Run the simulation by processing events until the simulation time is reached.
        """
        # תזמון האירועים הראשוניים בתחילת הסימולציה
        self.scheduleEvent(OpenHotelEvent(480))        # פתיחת המלון ב-8:00 בבוקר

        # עיבוד האירועים עד שהסימולציה מסתיימת
        while self.event_list and self.clock < self.simulationTime:
            event = heapq.heappop(self.event_list)  # שליפת האירוע הבא
            self.clock = event.time  # עדכון השעון לזמן האירוע
            event.handle(self)  # טיפול באירוע

        # בדיקה והדפסה של תוצאות הסימולציה
        self.displaySimulationResults()

    def displaySimulationResults(self):
        """
        Display the final results of the simulation.
        """
        print("Available rooms:", self.hotelSimulation.count_free_rooms())
        ###
        # print("Hotel Rank:", self.hotelSimulation.hotel_rank)
        print("Total guest groups:", self.hotelSimulation.total_guest_groups)  # סך כל הקבוצות שהתארחו במלון
        print("Total breakfast arrivals:", len(self.hotelSimulation.diningRoom.current_bookings))  # סך כל הכניסות לארוחת הבוקר
        ###print("Total breakfast exits:", len(self.hotelSimulation.diningRoom.waiting_queue))  # סך כל היציאות מארוחת הבוקר
        print("Total guest assign:", self.hotelSimulation.assignRoomscount)
        print("Total checkinq:", self.hotelSimulation.count_chekin_queue)
        print(f"Lobby queue size: {len(self.hotelSimulation.lobby_queue)}")
        print("Total nothaveroom:", self.hotelSimulation.nothaveroom)
check = Simulation(60 * 24 * 8)  # הרצה של הסימולציה ל-10 ימים
check.run()